package services

import (
	"database/sql"
	"errors"
	"fmt"
	"ps_club_backend/internal/models"
	"ps_club_backend/internal/repositories"
	"strings"
	"time"
)

// --- Custom Service Errors for Inventory Movement ---
var (
	ErrInvalidMovementType    = errors.New("invalid inventory movement type")
	ErrMovementItemNotFound   = errors.New("item for inventory movement not found")
	ErrMovementItemNotTracked = errors.New("item for inventory movement does not track stock")
	ErrMovementCreationFailed  = errors.New("failed to create inventory movement")
	ErrStockUpdateFailed      = errors.New("failed to update stock after movement")
)

// MovementType constants - ensure these are comprehensive and match usage elsewhere
const (
	MovementTypePurchase           string = "purchase"
	MovementTypeSale               string = "sale" // Handled by OrderService
	MovementTypeAdjustmentIn       string = "adjustment_in"
	MovementTypeAdjustmentOut      string = "adjustment_out"
	MovementTypeSpoilage           string = "spoilage"
	MovementTypeReturnCancellation string = "return_cancellation" // Handled by OrderService
	MovementTypeReturnDeletion     string = "return_deletion"     // Handled by OrderService
)

// --- Inventory Movement DTOs ---
type CreateInventoryMovementRequest struct {
	PricelistItemID int64   `json:"pricelist_item_id" binding:"required"`
	StaffID         *int64  `json:"staff_id"` // If nil, authenticated user's ID is used. Admin can override.
	MovementType    string  `json:"movement_type" binding:"required"`
	QuantityChanged int     `json:"quantity_changed" binding:"required"` // Always positive; service determines sign for stock update
	Reason          *string `json:"reason"`
}

// --- InventoryMovementService Interface ---
type InventoryMovementService interface {
	CreateMovement(req CreateInventoryMovementRequest, authenticatedStaffID int64) (*models.InventoryMovement, error)
	GetMovements(itemID *int64, staffID *int64, movementType *string, page, pageSize int) ([]models.InventoryMovement, int, error)
}

// --- inventoryMovementService Implementation ---
type inventoryMovementService struct {
	inventoryMvRepo repositories.InventoryMovementRepository
	pricelistRepo   repositories.PricelistRepository
	db              *sql.DB
}

// NewInventoryMovementService creates a new instance of InventoryMovementService.
func NewInventoryMovementService(
	imr repositories.InventoryMovementRepository,
	pr repositories.PricelistRepository,
	db *sql.DB,
) InventoryMovementService {
	return &inventoryMovementService{
		inventoryMvRepo: imr,
		pricelistRepo:   pr,
		db:              db,
	}
}

// --- Method Implementations ---

func (s *inventoryMovementService) CreateMovement(req CreateInventoryMovementRequest, authenticatedStaffID int64) (*models.InventoryMovement, error) {
	var stockChangeMultiplier int
	normalizedMovementType := strings.ToLower(req.MovementType)

	switch normalizedMovementType {
	case MovementTypePurchase, MovementTypeAdjustmentIn:
		if req.QuantityChanged <= 0 {
			return nil, fmt.Errorf("%w: quantity for '%s' movement must be positive", ErrValidation, req.MovementType)
		}
		stockChangeMultiplier = 1 // Positive change
	case MovementTypeAdjustmentOut, MovementTypeSpoilage:
		if req.QuantityChanged <= 0 {
			return nil, fmt.Errorf("%w: quantity for '%s' movement must be positive (it will be deducted from stock)", ErrValidation, req.MovementType)
		}
		stockChangeMultiplier = -1 // Negative change
	case MovementTypeSale, MovementTypeReturnCancellation, MovementTypeReturnDeletion:
		// These types are typically system-generated by OrderService and reflect stock changes already.
		// Manual creation for these types via this endpoint might be disallowed or require special handling.
		// For now, disallowing to prevent accidental stock duplication or complex logic here.
		return nil, fmt.Errorf("%w: movement type '%s' is system-reserved or should be handled by order operations", ErrInvalidMovementType, req.MovementType)
	default:
		return nil, fmt.Errorf("%w: unknown type '%s'", ErrInvalidMovementType, req.MovementType)
	}

	actualStockChange := req.QuantityChanged * stockChangeMultiplier

	// Determine StaffID to use for the movement record
	staffIDForRecord := authenticatedStaffID
	if req.StaffID != nil { // Allow admin to override or specify for record-keeping
		staffIDForRecord = *req.StaffID
	}

	// Verify pricelist item
	_, _, _, tracksStock, err := s.pricelistRepo.GetItemPriceAndStock(req.PricelistItemID)
	if err != nil {
		if errors.Is(err, repositories.ErrNotFound) {
			return nil, fmt.Errorf("%w: pricelist item with ID %d not found", ErrMovementItemNotFound, req.PricelistItemID)
		}
		return nil, fmt.Errorf("failed to verify pricelist item details: %w", err)
	}
	if !tracksStock {
		return nil, fmt.Errorf("%w: item ID %d", ErrMovementItemNotTracked, req.PricelistItemID)
	}

	// Start transaction
	tx, err := s.db.Begin()
	if err != nil {
		return nil, fmt.Errorf("failed to start database transaction: %w", err)
	}
	defer tx.Rollback() // Ensure rollback if commit is not successful

	movement := &models.InventoryMovement{
		PricelistItemID: req.PricelistItemID,
		StaffID:         &staffIDForRecord, // StaffID is nullable in model
		MovementType:    normalizedMovementType,
		QuantityChanged: actualStockChange, // This is the actual change to stock (+ve or -ve)
		Reason:          req.Reason,
		MovementDate:    time.Now(), // Service sets the movement date
	}

	movementID, err := s.inventoryMvRepo.CreateMovement(tx, movement)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", ErrMovementCreationFailed, err)
	}
	movement.ID = movementID // Set the ID on the model

	// Update stock in pricelist_items table
	_, err = s.pricelistRepo.UpdateStock(tx, req.PricelistItemID, actualStockChange)
	if err != nil {
		// UpdateStock in repo already handles ErrNotFound or if item doesn't track stock.
		// Map that error or provide a more generic one.
		return nil, fmt.Errorf("%w: for item ID %d: %v", ErrStockUpdateFailed, req.PricelistItemID, err)
	}

	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction for inventory movement: %w", err)
	}

	// Fetch the full movement details to return (including joins if repo supports it)
	// For now, GetMovements is for lists. A GetMovementByID would be better.
	// Let's populate what we can.
	createdMovement, fetchErr := s.fetchMovementDetails(movement.ID)
	if fetchErr != nil {
		// Log this error, but return the original movement data as a fallback
		fmt.Printf("Warning: failed to fetch full movement details after creation (ID: %d): %v\n", movement.ID, fetchErr)
		// Ensure basic details are set
		movement.CreatedAt = time.Now() // Approximate, DB has actual
		movement.UpdatedAt = time.Now()
		return movement, nil 
	}

	return createdMovement, nil
}

// helper to fetch movement details - ideally GetMovementByID in repo
func (s *inventoryMovementService) fetchMovementDetails(movementID int64) (*models.InventoryMovement, error) {
    // This is a simplified fetch. Ideally, repo.GetMovementByID(movementID)
    movements, _, err := s.inventoryMvRepo.GetMovements(nil, nil, nil, 1, 1) // This is not ideal for fetching one specific ID
    if err != nil {
        return nil, err
    }
    for _, m := range movements {
        if m.ID == movementID {
            return &m, nil
        }
    }
    // If not found via list (which is bad), try to construct minimal info
    // Or, this indicates a need for GetMovementByID in the repository.
    // For now, this is a placeholder for proper fetching.
    return nil, fmt.Errorf("failed to fetch movement details for ID %d post-creation (GetMovementByID not implemented)", movementID)
}


func (s *inventoryMovementService) GetMovements(itemID *int64, staffID *int64, movementType *string, page, pageSize int) ([]models.InventoryMovement, int, error) {
	if page <= 0 { page = 1 }
	if pageSize <= 0 { pageSize = 10 } 

	movements, totalCount, err := s.inventoryMvRepo.GetMovements(itemID, staffID, movementType, page, pageSize)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to get inventory movements: %w", err)
	}
	return movements, totalCount, nil
}
